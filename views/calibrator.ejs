<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>
        <%= title %>
    </title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Optional: your existing CSS (won't break if missing, just 404s) -->
    <link rel="stylesheet" href="/css/styles.css" />
    <link rel="stylesheet" href="/css/bcit-map.css" />

    <!-- Mapbox GL CSS & JS -->
    <link href="https://api.mapbox.com/mapbox-gl-js/v3.5.1/mapbox-gl.css" rel="stylesheet" />
    <script src="https://api.mapbox.com/mapbox-gl-js/v3.5.1/mapbox-gl.js"></script>

    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        }

        .calibrator-layout {
            display: flex;
            height: calc(100vh - 60px);
            /* adjust if your header is taller/shorter */
        }

        .calibrator-sidebar {
            width: 340px;
            max-width: 40%;
            padding: 12px;
            border-right: 1px solid #ddd;
            background: #fafafa;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .calibrator-sidebar h2 {
            margin: 0 0 4px;
            font-size: 18px;
        }

        .calibrator-sidebar small {
            color: #555;
        }

        .file-row {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-top: 8px;
        }

        .file-row label {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        #geojson-file {
            font-size: 13px;
        }

        #file-info {
            font-size: 11px;
            color: #666;
        }

        .button-row {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        button {
            padding: 6px 12px;
            font-size: 13px;
            border-radius: 4px;
            border: 1px solid #999;
            background: #f0f0f0;
            cursor: pointer;
        }

        button:hover {
            background: #e0e0e0;
        }

        button.primary {
            background: #0078ff;
            border-color: #0078ff;
            color: #fff;
        }

        button.primary:hover {
            background: #0062cc;
        }

        #status {
            font-size: 12px;
            margin-top: 6px;
            color: #333;
            min-height: 1.2em;
            white-space: pre-line;
        }

        #geojson-output {
            margin-top: 8px;
            height: 120px;
            width: 100%;
            resize: vertical;
            font-family: "JetBrains Mono", Consolas, monospace;
            font-size: 11px;
            box-sizing: border-box;
        }

        #map {
            flex: 1;
            position: relative;
            min-width: 0;
        }
    </style>
</head>

<body>
    <%- include("_menu") %>

        <div class="calibrator-layout">
            <aside class="calibrator-sidebar">
                <h2>Geometry Calibrator</h2>
                <small>
                    Choose a <b>.geojson</b> or <b>.json</b> file, drag the shape on the map,
                    then export the updated GeoJSON.
                </small>

                <div class="file-row">
                    <label for="geojson-file">Input GeoJSON File</label>
                    <input type="file" id="geojson-file"
                        accept=".geojson,.json,application/geo+json,application/json" />
                    <small id="file-info"></small>
                </div>

                <div class="button-row">
                    <button id="clear-btn">Clear Map</button>
                    <button id="export-btn" class="primary">Export Edited GeoJSON</button>
                </div>

                <div id="status"></div>

                <textarea id="geojson-output" placeholder="Exported GeoJSON will appear here when you click Export."
                    readonly></textarea>
            </aside>

            <div id="map"></div>
        </div>

        <script>
            // ==============================
            //  MAP SETUP
            // ==============================
            mapboxgl.accessToken = "<%= mapboxToken %>";

            const MAP_STYLE = "mapbox://styles/mapbox/streets-v12"; // adjust if you use a custom style

            const map = new mapboxgl.Map({
                container: "map",
                style: MAP_STYLE,
                center: [-123.001, 49.25], // adjust to your main map's default center
                zoom: 16
            });

            map.addControl(new mapboxgl.NavigationControl(), "top-right");

            // ==============================
            //  DOM ELEMENTS
            // ==============================
            const fileInput = document.getElementById("geojson-file");
            const fileInfoEl = document.getElementById("file-info");
            const statusEl = document.getElementById("status");
            const outputEl = document.getElementById("geojson-output");
            const clearBtn = document.getElementById("clear-btn");
            const exportBtn = document.getElementById("export-btn");

            function setStatus(message) {
                statusEl.textContent = message || "";
            }

            // ==============================
            //  GEOJSON HELPERS
            // ==============================

            function toFeatureCollection(json) {
                if (!json || !json.type) {
                    throw new Error("Invalid GeoJSON: missing 'type'.");
                }

                if (json.type === "FeatureCollection") return json;

                if (json.type === "Feature") {
                    return { type: "FeatureCollection", features: [json] };
                }

                if (json.type === "GeometryCollection") {
                    return {
                        type: "FeatureCollection",
                        features: (json.geometries || []).map((g) => ({
                            type: "Feature",
                            properties: {},
                            geometry: g
                        }))
                    };
                }

                const geometryTypes = [
                    "Point", "MultiPoint",
                    "LineString", "MultiLineString",
                    "Polygon", "MultiPolygon"
                ];

                if (geometryTypes.includes(json.type)) {
                    return {
                        type: "FeatureCollection",
                        features: [{ type: "Feature", properties: {}, geometry: json }]
                    };
                }

                if (json.type === "Topology") {
                    throw new Error("File looks like TopoJSON (type=Topology). Convert to GeoJSON first.");
                }

                throw new Error("Unsupported GeoJSON root type: " + json.type);
            }

            function computeBbox(featureCollection) {
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

                function scan(coords) {
                    if (!coords) return;
                    if (typeof coords[0] === "number") {
                        const [lng, lat] = coords;
                        if (lng < minX) minX = lng;
                        if (lat < minY) minY = lat;
                        if (lng > maxX) maxX = lng;
                        if (lat > maxY) maxY = lat;
                    } else {
                        for (const c of coords) scan(c);
                    }
                }

                for (const f of featureCollection.features || []) {
                    if (!f.geometry) continue;
                    if (f.geometry.type === "GeometryCollection") {
                        for (const g of f.geometry.geometries || []) scan(g.coordinates);
                    } else {
                        scan(f.geometry.coordinates);
                    }
                }

                if (minX === Infinity) return null;
                return [minX, minY, maxX, maxY];
            }

            // Center = simple average of all coords
            function computeCenter(featureCollection) {
                let sumLng = 0;
                let sumLat = 0;
                let count = 0;

                function scan(coords) {
                    if (!coords) return;
                    if (typeof coords[0] === "number") {
                        sumLng += coords[0];
                        sumLat += coords[1];
                        count++;
                    } else {
                        for (const c of coords) scan(c);
                    }
                }

                for (const f of featureCollection.features || []) {
                    if (!f.geometry) continue;
                    if (f.geometry.type === "GeometryCollection") {
                        for (const g of f.geometry.geometries || []) scan(g.coordinates);
                    } else {
                        scan(f.geometry.coordinates);
                    }
                }

                if (!count) return null;
                return { lng: sumLng / count, lat: sumLat / count };
            }

            // Simple distance in lon/lat space (good enough for relative scaling)
            function lngLatDistance(a, b) {
                const dx = b.lng - a.lng;
                const dy = b.lat - a.lat;
                return Math.sqrt(dx * dx + dy * dy);
            }

            // Generic transformer for deeply nested coordinate arrays
            function transformCoords(coords, fn) {
                if (!coords) return coords;
                if (typeof coords[0] === "number") {
                    return fn(coords);
                }
                return coords.map((c) => transformCoords(c, fn));
            }

            // ==============================
            //  STATE FOR DRAGGING & SCALING
            // ==============================
            const SOURCE_ID = "calibrator-geom";
            const FILL_LAYER_ID = "calibrator-fill";
            const LINE_LAYER_ID = "calibrator-outline";

            let currentData = null;      // current FeatureCollection on map
            let originalData = null;     // snapshot at drag start
            let dragStartLngLat = null;
            let isDragging = false;
            let interactionMode = null;  // "translate" or "scale"
            let scaleStartCenter = null;
            let scaleStartRadius = null;

            function ensureLayers() {
                if (!map.getSource(SOURCE_ID)) {
                    map.addSource(SOURCE_ID, {
                        type: "geojson",
                        data: { type: "FeatureCollection", features: [] }
                    });
                }

                if (!map.getLayer(FILL_LAYER_ID)) {
                    map.addLayer({
                        id: FILL_LAYER_ID,
                        type: "fill",
                        source: SOURCE_ID,
                        paint: {
                            "fill-color": "#ff8800",
                            "fill-opacity": 0.35
                        }
                    });
                }

                if (!map.getLayer(LINE_LAYER_ID)) {
                    map.addLayer({
                        id: LINE_LAYER_ID,
                        type: "line",
                        source: SOURCE_ID,
                        paint: {
                            "line-color": "#ff5500",
                            "line-width": 2
                        }
                    });
                }
            }

            // ==============================
            //  FILE UPLOAD â†’ LOAD SHAPE
            // ==============================
            fileInput.addEventListener("change", () => {
                const file = fileInput.files && fileInput.files[0];
                if (!file) {
                    fileInfoEl.textContent = "";
                    return;
                }

                fileInfoEl.textContent = `Selected: ${file.name} (${Math.round(file.size / 1024)} KB)`;

                const reader = new FileReader();

                reader.onload = (event) => {
                    let json;
                    try {
                        json = JSON.parse(event.target.result);
                    } catch (err) {
                        console.error("JSON parse error:", err);
                        setStatus("âŒ Error: file is not valid JSON.");
                        return;
                    }

                    let fc;
                    try {
                        fc = toFeatureCollection(json);
                    } catch (err) {
                        console.error("GeoJSON normalisation error:", err);
                        setStatus("âŒ " + err.message);
                        return;
                    }

                    currentData = fc;
                    originalData = JSON.parse(JSON.stringify(fc)); // deep copy

                    ensureLayers();
                    const src = map.getSource(SOURCE_ID);
                    src.setData(fc);

                    const bbox = computeBbox(fc);
                    if (bbox) {
                        map.fitBounds(bbox, { padding: 40, maxZoom: 20 });
                    }

                    setStatus(
                        "ðŸ“¥ Loaded " +
                        fc.features.length +
                        " feature(s).\n" +
                        "Tip: Drag to move. Hold Shift and drag to resize."
                    );
                };

                reader.onerror = () => {
                    console.error("FileReader error");
                    setStatus("âŒ Error reading file.");
                };

                reader.readAsText(file);
            });

            // ==============================
            //  DRAGGING & RESIZING
            // ==============================
            function onDragStart(e) {
                if (!currentData) return;

                e.preventDefault();
                map.dragPan.disable();

                // Shift + drag = scale, plain drag = move
                const isScale = e.originalEvent && e.originalEvent.shiftKey;
                interactionMode = isScale ? "scale" : "translate";
                isDragging = true;
                dragStartLngLat = e.lngLat;
                originalData = JSON.parse(JSON.stringify(currentData)); // snapshot

                if (interactionMode === "scale") {
                    map.getCanvas().style.cursor = "nwse-resize"; // or any resize cursor
                    scaleStartCenter = computeCenter(originalData);
                    if (!scaleStartCenter) {
                        // fall back to translate if we can't compute center
                        interactionMode = "translate";
                        map.getCanvas().style.cursor = "grabbing";
                    } else {
                        scaleStartRadius = lngLatDistance(scaleStartCenter, dragStartLngLat);
                    }
                } else {
                    map.getCanvas().style.cursor = "grabbing";
                }
            }

            function onDragMove(e) {
                if (!isDragging || !originalData || !interactionMode) return;

                if (interactionMode === "translate") {
                    const dx = e.lngLat.lng - dragStartLngLat.lng;
                    const dy = e.lngLat.lat - dragStartLngLat.lat;

                    const moved = {
                        type: "FeatureCollection",
                        features: originalData.features.map((f) => {
                            if (!f.geometry) return f;
                            const g = JSON.parse(JSON.stringify(f.geometry));

                            if (g.type === "GeometryCollection") {
                                g.geometries = g.geometries.map((geom) => {
                                    const geomCopy = JSON.parse(JSON.stringify(geom));
                                    geomCopy.coordinates = transformCoords(geomCopy.coordinates, ([lng, lat]) => [
                                        lng + dx,
                                        lat + dy
                                    ]);
                                    return geomCopy;
                                });
                            } else {
                                g.coordinates = transformCoords(g.coordinates, ([lng, lat]) => [
                                    lng + dx,
                                    lat + dy
                                ]);
                            }

                            return {
                                type: "Feature",
                                properties: JSON.parse(JSON.stringify(f.properties || {})),
                                geometry: g
                            };
                        })
                    };

                    currentData = moved;
                    const src = map.getSource(SOURCE_ID);
                    if (src) src.setData(moved);
                } else if (interactionMode === "scale" && scaleStartCenter) {
                    const currentRadius = lngLatDistance(scaleStartCenter, e.lngLat);
                    if (!scaleStartRadius || scaleStartRadius === 0) return;

                    const scale = currentRadius / scaleStartRadius;

                    const scaled = {
                        type: "FeatureCollection",
                        features: originalData.features.map((f) => {
                            if (!f.geometry) return f;
                            const g = JSON.parse(JSON.stringify(f.geometry));

                            const center = scaleStartCenter;

                            const scaleFn = ([lng, lat]) => [
                                center.lng + (lng - center.lng) * scale,
                                center.lat + (lat - center.lat) * scale
                            ];

                            if (g.type === "GeometryCollection") {
                                g.geometries = g.geometries.map((geom) => {
                                    const geomCopy = JSON.parse(JSON.stringify(geom));
                                    geomCopy.coordinates = transformCoords(geomCopy.coordinates, scaleFn);
                                    return geomCopy;
                                });
                            } else {
                                g.coordinates = transformCoords(g.coordinates, scaleFn);
                            }

                            return {
                                type: "Feature",
                                properties: JSON.parse(JSON.stringify(f.properties || {})),
                                geometry: g
                            };
                        })
                    };

                    currentData = scaled;
                    const src = map.getSource(SOURCE_ID);
                    if (src) src.setData(scaled);
                }
            }

            function onDragEnd() {
                if (!isDragging) return;
                isDragging = false;
                dragStartLngLat = null;
                interactionMode = null;
                map.getCanvas().style.cursor = "";
                map.dragPan.enable();
                setStatus("âœ… Shape updated. You can export the new GeoJSON.");
            }

            map.on("load", () => {
                ensureLayers();

                map.on("mousedown", FILL_LAYER_ID, onDragStart);
                map.on("mousedown", LINE_LAYER_ID, onDragStart);

                map.on("mousemove", onDragMove);
                map.on("mouseup", onDragEnd);
                map.on("mouseleave", onDragEnd);
            });

            // ==============================
            //  CLEAR MAP
            // ==============================
            clearBtn.addEventListener("click", () => {
                const src = map.getSource(SOURCE_ID);
                if (src) {
                    src.setData({ type: "FeatureCollection", features: [] });
                }
                currentData = null;
                originalData = null;
                outputEl.value = "";
                setStatus("ðŸ§¹ Cleared all features from map.");
            });

            // ==============================
            //  EXPORT EDITED GEOJSON
            // ==============================
            exportBtn.addEventListener("click", () => {
                if (!currentData || !currentData.features || currentData.features.length === 0) {
                    setStatus("âš  No features to export.");
                    return;
                }

                const json = JSON.stringify(currentData, null, 2);
                outputEl.value = json;

                const blob = new Blob([json], { type: "application/vnd.geo+json" });
                const url = URL.createObjectURL(blob);

                const a = document.createElement("a");
                const timestamp = new Date().toISOString().replace(/[:T]/g, "-").slice(0, 19);
                a.href = url;
                a.download = `edited-geometry-${timestamp}.geojson`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

                URL.revokeObjectURL(url);

                setStatus(`ðŸ’¾ Exported ${currentData.features.length} feature(s) as GeoJSON.`);
            });
        </script>

</body>

</html>